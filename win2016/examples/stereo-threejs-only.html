<!DOCTYPE html>
<title>TEST STEREO</title>
<meta charset="utf-8" name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<script src="../vendor/threejs/original/build/three.js"></script>
<script src="../vendor/threejs/patched/examples/js/effects/StereoEffect.js"></script>
<script src="vendor/three.js/examples/js/renderers/CSS3DStereoRenderer.js"></script>
<script src="../vendor/threejs/original/examples/js/controls/OrbitControls.js"></script>

<style media="screen">
html, body {
        margin: 0px; 
        overflow: hidden; 
        height: 100%;
}

.fourjs {
        height: 100%;
        position: relative;
        background-color:#000;
}
.test{
        width: 20px;
        height: 1px;
        background-color:rgba(255,0,0, 0.5);
}
</style>
<body><script>
//////////////////////////////////////////////////////////////////////////////////
//		Import render loop
//////////////////////////////////////////////////////////////////////////////////
// array of functions for the rendering loop
var onRenderFcts= [];

//////////////////////////////////////////////////////////////////////////////////
//		Comments
//////////////////////////////////////////////////////////////////////////////////

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild(renderer.domElement)


var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
camera.position.set(0,5,15);


var controls = new THREE.OrbitControls( camera, renderer.domElement );
onRenderFcts.push(function(){
        controls.update();
})

//////////////////////////////////////////////////////////////////////////////////
//		initialize renderer for css coverflow
//////////////////////////////////////////////////////////////////////////////////

var rendererCss = new THREE.CSS3DStereoRenderer();

rendererCss.separation = 2;
rendererCss.targetDistance = 500;

rendererCss.setSize( window.innerWidth, window.innerHeight );
rendererCss.domElement.style.position = 'absolute';
rendererCss.domElement.style.top = '0px';
rendererCss.domElement.style.pointerEvents = 'none';
rendererCss.domElement.classList.add('css3dContainer')
document.body.appendChild( rendererCss.domElement );
// render the scene
onRenderFcts.push(function(){
        // to actually render the scene   
        rendererCss.render( sceneCss, camera );
})



var sceneCss = new THREE.Scene()


var domElement = document.createElement('div');
domElement.className = "test";
var object3d = new THREE.CSS3DObject( domElement );          
sceneCss.add(object3d);

//////////////////////////////////////////////////////////////////////////////
//              Code Separator
//////////////////////////////////////////////////////////////////////////////

var light	= new THREE.AmbientLight( 0x080808 )
scene.add( light )
// add a light in front
var light2	= new THREE.DirectionalLight('white', 0.5)
light2.position.set(0.5, 2, 0.1)
scene.add( light2 )


//////////////////////////////////////////////////////////////////////////////
//              Code Separator
//////////////////////////////////////////////////////////////////////////////

var geometry = new THREE.BoxGeometry( 5, 1, 0.1 );
var material = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh( geometry, material );
cube.position.z=3
scene.add( cube );

// grid
var gridHelper = new THREE.GridHelper( 10, 1 ); 
scene.add( gridHelper );

//////////////////////////////////////////////////////////////////////////////
//              STEREO rendererCss
//////////////////////////////////////////////////////////////////////////////
var effect = new THREE.StereoEffect( renderer );
effect.eyeSeparation = 4;
effect.focalLength = 500;
effect.setSize( window.innerWidth, window.innerHeight );

onRenderFcts.push(function(){
        effect.render( scene, camera );
})

//////////////////////////////////////////////////////////////////////////////
//              STEREO
//////////////////////////////////////////////////////////////////////////////

// run the rendering loop
var lastTimeMsec= null
requestAnimationFrame(function animate(nowMsec){
        // keep looping
        requestAnimationFrame( animate );
        // measure time
        lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
        var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec	= nowMsec
        // call each update function
        onRenderFcts.forEach(function(onRenderFct){
                onRenderFct(deltaMsec/1000, nowMsec/1000)
        })
})


</script></body>